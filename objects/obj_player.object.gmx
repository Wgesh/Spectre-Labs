<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_player_idle</spriteName>
  <solid>-1</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// setup start ///

movement = 1; // 0 disabled // 1 enabled //
movetimer = 0; // to stall player movement //
slidetimer = 0; // smooth animation sliding of player //
depth = -11 // bring player forward //

//global.recordpath = path_add(); // path recording //
//path_set_closed(global.recordpath, false); // sets path to open //

shoottimer = 0; // stalled shooting //
// shootdir = 1; // 1 = 0deg // 2 = 90deg // 3 = 180deg // 4 = 270deg // not used

global.recordpathx = ds_list_create(); // list for x recording //
global.recordpathy = ds_list_create(); // list for x recording //
recording = false // false = not recording // true = recording //
playback = false // false = not playing recording // true = playing recording //
recordtimer = 0; // recording timer //
recordstartingx = 0;
recordstartingy = 0;
snaptimer = 0; // timer to wait to snap to grid //

image_speed = 0.2;
//image_xscale = 1.5;
//image_yscale = 1.5;

global.playingback = false

/// setup end ///
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_movement_sliding(2,16);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// ghost recording start ///

// sets ongrid position to edge of tile (theoretically divisible) //
ongridx = x + 16
ongridy = y + 16

// if player is centered on a grid tile, allow recording to start, setup the recording //
if ongridx mod 32 = 0 and ongridy mod 32 = 0 {
    if global.playingback = false {
        if recording = false {
            if keyboard_check_pressed(ord('Q')) {
                recordstartingx = x;
                recordstartingy = y;
                
                ds_list_clear(global.recordpathx);
                ds_list_clear(global.recordpathy);
                
                image_blend = c_lime;
                
                recording = true;
                
                show_debug_message("started recordingg");
            }
        }
    }
}

// when recording started, start recording points //
if recording = true {
    recordtimer ++;

    ds_list_add(global.recordpathx,x);
    ds_list_add(global.recordpathy,y);
    
    // when time is up, check if player is centered on tile before finishing //
    if recordtimer &gt;= 300 {
    
        if ongridx mod 32 != 0 or ongridy mod 32 != 0 {
            show_debug_message("started snapping")
            
            
        } else {
            recording = false
            playback = false
            
            
            image_blend = c_white;
            x = recordstartingx;
            y = recordstartingy;
            
            snaptimer = 0;
            recordtimer = 0;
        }
        
        show_debug_message("recording finished");
    }
}

/// ghost recording end ///
/// ghost playback start ///

// if not recording or already playing, check for keypress and turn on playback variable //
if recording = false and playback = false {
    if keyboard_check_pressed(ord('E')) {
        show_debug_message("playback started");
        playback = true;
        instance_create(recordstartingx, recordstartingy, obj_ghost);
    }
}

/// ghost playback end ///
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// sprite control ///
if global.movecontrollock = false {
    if movement = 1 {
        if keyboard_check(ord('A')) {
            sprite_index = spr_player_run;
            image_xscale = -1;
        } else if keyboard_check(ord('D')) {
            sprite_index = spr_player_run;
            image_xscale = 1;
        } else if keyboard_check(ord('W')) {
            sprite_index = spr_player_run;
        } else if keyboard_check(ord('S')) {
            sprite_index = spr_player_run;
        } else {
            sprite_index = spr_player_idle;
        }
    }
} else {
    if movement = 1 {
        sprite_index = spr_player_idle;
    }
}

if place_meeting(x,y-32,obj_server) {
    depth = -13;
} else {
    depth = -11;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// keyboard movement checking start ///

// checks for keyboard input and other parameters to move the player //
// sets alarm, slidetimer, movement, movetimer //
if global.movecontrollock = false {

    if global.block1stuckdir != 3 {
        if keyboard_check(ord('A')) {
            if movement = 1 {
                direction = 180;
        
                if !place_meeting(x-32,y,obj_metal_wall_l1)
                and !place_meeting(x-32,y,obj_metal_wall_l5)
                and !place_meeting(x-32,y,obj_metal_wall_bk1)
                and !place_meeting(x-32,y,obj_metal_floor_oneway_left)
                and !place_meeting(x-32,y,obj_barrier_block)
                and !place_meeting(x-32,y,obj_door_bot_green)
                and !place_meeting(x-32,y,obj_door_top_green)
                and !place_meeting(x-32,y,obj_door_bot_red)
                and !place_meeting(x-32,y,obj_door_top_red)
                and !place_meeting(x-32,y,obj_door_bot_blue)
                and !place_meeting(x-32,y,obj_door_top_blue)
                and !place_meeting(x-32,y,obj_door_bot_blue_n)
                and !place_meeting(x-32,y,obj_door_top_blue_n)
                and !place_meeting(x-32,y,obj_door_bot_orange)
                and !place_meeting(x-32,y,obj_door_top_orange)
                and !place_meeting(x-32,y,obj_forcefield) {
                
                    slidetimer = 0;
                    alarm[0] = 1;
        
                    movement = 0;
                    movetimer = 16;
                }
            } 
        } 
    }

    if global.block1stuckdir != 1 {
        if keyboard_check(ord('D')) {
            if movement = 1 {
                direction = 0;
            
                if !place_meeting(x+32,y,obj_metal_wall_r1)
                and !place_meeting(x+32,y,obj_metal_wall_r5)
                and !place_meeting(x+32,y,obj_metal_wall_bk1)
                and !place_meeting(x+32,y,obj_metal_floor_oneway_right)
                and !place_meeting(x+32,y,obj_barrier_block)
                and !place_meeting(x+32,y,obj_door_bot_green)
                and !place_meeting(x+32,y,obj_door_top_green)
                and !place_meeting(x+32,y,obj_door_bot_red)
                and !place_meeting(x+32,y,obj_door_top_red)
                and !place_meeting(x+32,y,obj_door_bot_blue)
                and !place_meeting(x+32,y,obj_door_top_blue)
                and !place_meeting(x+32,y,obj_door_bot_blue_n)
                and !place_meeting(x+32,y,obj_door_top_blue_n)
                and !place_meeting(x+32,y,obj_door_bot_orange)
                and !place_meeting(x+32,y,obj_door_top_orange)
                and !place_meeting(x+32,y,obj_forcefield) {
                
                    slidetimer = 0;
                    alarm[0] = 1;
            
                    movement = 0;
                    movetimer = 16;
                }
            }
        }
    }

    if global.block1stuckdir != 2 {
        if keyboard_check(ord('W')) {
            if movement = 1 {
                direction = 90;
            
                if !place_meeting(x,y-32,obj_metal_wall_bk1)
                and !place_meeting(x,y-32,obj_metal_floor_oneway_top)
                and !place_meeting(x,y-32,obj_barrier_block)
                and !place_meeting(x,y-32,obj_door_left_green) 
                and !place_meeting(x,y-32,obj_door_right_green)
                and !place_meeting(x,y-32,obj_door_left_red)
                and !place_meeting(x,y-32,obj_door_right_red)
                and !place_meeting(x,y-32,obj_door_right_blue)
                and !place_meeting(x,y-32,obj_door_left_blue)
                and !place_meeting(x,y-32,obj_door_right_blue_n)
                and !place_meeting(x,y-32,obj_door_left_blue_n)
                and !place_meeting(x,y-32,obj_door_left_orange)
                and !place_meeting(x,y-32,obj_door_right_orange)
                and !place_meeting(x,y-32,obj_forcefield) {
                    
                    slidetimer = 0;
                    alarm[0] = 1;
            
                    movement = 0;
                    movetimer = 16;
                }
            }
        }
    }

    if global.block1stuckdir != 4 {
        if keyboard_check(ord('S')) {
            if movement = 1 {
                direction = 270;
            
                    if !place_meeting(x,y+32,obj_metal_wall_fr1)
                    and !place_meeting(x,y+32,obj_metal_wall_fr1_door)
                    and !place_meeting(x,y+32,obj_metal_wall_fr2)
                    and !place_meeting(x,y+32,obj_metal_wall_r5)
                    and !place_meeting(x,y+32,obj_metal_wall_l5)
                    and !place_meeting(x,y+32,obj_metal_floor_oneway_bot)
                    and !place_meeting(x,y+32,obj_barrier_block)
                    and !place_meeting(x,y+32,obj_door_left_green)
                    and !place_meeting(x,y+32,obj_door_right_green)
                    and !place_meeting(x,y+32,obj_door_left_red)
                    and !place_meeting(x,y+32,obj_door_right_red)
                    and !place_meeting(x,y+32,obj_door_left_blue)
                    and !place_meeting(x,y+32,obj_door_right_blue)
                    and !place_meeting(x,y+32,obj_door_left_blue_n)
                    and !place_meeting(x,y+32,obj_door_right_blue_n)
                    and !place_meeting(x,y+32,obj_door_left_orange)
                    and !place_meeting(x,y+32,obj_door_right_orange)
                    and !place_meeting(x,y+32,obj_forcefield) {
                    
                    slidetimer = 0;
                    alarm[0] = 1;
            
                    movement = 0;
                    movetimer = 16;
                }
            }
        }
    }

}

/// keyboard movement checking end ///
/// movement checking for push block held up against wall ///


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// stalled movement start ///

// if disabled movement, decrease movetimer //
if movement = 0 {
    movetimer -= 1;
}

// if movetimer &lt;= 0, enable movement //
if movetimer &lt;= 0 {
    movement = 1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// level completion start ///

// if player past top of room, according to room, act accordingly //
if place_meeting(x,y,obj_level_complete) {
    if room = /*room_tutorial*/ room_feature_test {
        global.fadein = 1;
        instance_create(0,0,obj_fade);
    }
    if room = room_level1 {
        global.fadein = 1;
        instance_create(0,0,obj_fade);    
    }
}

/// level completion end ///
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// shooting ///

shoottimer ++

if global.movecontrollock = false {
    if shoottimer &gt;= 1 {
        if keyboard_check_pressed(vk_right) {
            laser = instance_create(x,y,obj_player_laser)
            laser.direction = 0;
            laser.speed = 15;
            laser.image_angle = 0;
            shoottimer = 0;
        }
        
        if keyboard_check_pressed(vk_up) {
            laser = instance_create(x,y,obj_player_laser)
            laser.direction = 90;
            laser.speed = 15;
            laser.image_angle = 90;
            shoottimer = 0;
        }
       
       if keyboard_check_pressed(vk_left) {
            laser = instance_create(x,y,obj_player_laser)
            laser.direction = 180;
            laser.speed = 15;
            laser.image_angle = 180;
            shoottimer = 0;
       }
        
        if keyboard_check_pressed(vk_down) {
            laser = instance_create(x,y,obj_player_laser)
            laser.direction = 270;
            laser.speed = 15;
            laser.image_angle = 270;
            shoottimer = 0;
        }
        
    }
}
if shoottimer &gt;= 1 {
    shoottimer = 1;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// bullet collision check ///
if place_meeting(x,y,obj_enemy_laser1) {
    with instance_nearest(x,y,obj_enemy_laser1) {
        effect_create_above(ef_smoke,x,y,0,c_white);
        instance_destroy();
    }
    global.playerhealth -= 4;
}

if global.bosswave = 4 {
    if place_meeting(x,y,obj_enemy_laser2) {
        with instance_nearest(x,y,obj_enemy_laser2) {
            effect_create_above(ef_smoke,x,y,0,c_white);
            //instance_destroy();
        }
        global.playerhealth -= 0.3;
    }
    
    if place_meeting(x,y,obj_enemy_laser2_beam) {
        with instance_nearest(x,y,obj_enemy_laser2_beam) {
            effect_create_above(ef_smoke,x,y,0,c_white);
            //instance_destroy();
        }
        global.playerhealth -= 0.3;
    }
} else {
    if place_meeting(x,y,obj_enemy_laser2) {
        with instance_nearest(x,y,obj_enemy_laser2) {
            effect_create_above(ef_smoke,x,y,0,c_white);
            instance_destroy();
        }
        global.playerhealth -= 6;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
